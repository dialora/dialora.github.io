<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn PRF Robust Test 2</title>
    <style>
        body { font-family: -apple-system, sans-serif; padding: 20px; max-width: 500px; margin: auto; background: #f9f9f9; }
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input { width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; font-size: 16px; }
        button { width: 100%; padding: 12px; background: #007AFF; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        button:active { opacity: 0.8; }
        #log { background: #222; color: #0f0; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; height: 200px; overflow-y: auto; white-space: pre-wrap; }
        .status-ok { color: green; font-weight: bold; }
        .status-err { color: red; font-weight: bold; }
    </style>
</head>
<body>

    <h3>WebAuthn Test</h3>
    <div id="check-status">Проверка...</div>

    <div class="card">
        <h4>1. Настройка (Регистрация)</h4>
        <input type="password" id="inp-master" placeholder="Мастер-пароль">
        <input type="text" id="inp-data" placeholder="Секретные данные">
        <button id="btn-setup">Создать Passkey и зашифровать</button>
        <p style="font-size: 11px; color: #666;">Внимание: может потребоваться ввести биометрию дважды (создание + первый ключ).</p>
    </div>

    <div class="card">
        <h4>2. Вход (Дешифровка)</h4>
        <button id="btn-unlock" style="background: #34C759;">Войти через FaceID / TouchID</button>
    </div>

    <div id="log">Консоль готова...</div>

    <script>
        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('check-status');
        const PRF_SALT = new Uint8Array(32).fill(0x73); // "s" - статичная соль 32 байта

        const logger = (msg, obj = null) => {
            const text = obj ? `${msg} ${JSON.stringify(obj, null, 2)}` : msg;
            logEl.innerText += `\n> ${text}`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg, obj);
        };

        // --- IDB UTILS ---
        const DB = {
            async open() {
                return new Promise(res => {
                    const r = indexedDB.open('PRF_Test', 1);
                    r.onupgradeneeded = () => r.result.createObjectStore('vault');
                    r.onsuccess = () => res(r.result);
                });
            },
            async save(val) {
                const db = await this.open();
                const tx = db.transaction('vault', 'readwrite');
                tx.objectStore('vault').put(val, 'user_data');
            },
            async get() {
                const db = await this.open();
                return new Promise(res => {
                    const r = db.transaction('vault').objectStore('vault').get('user_data');
                    r.onsuccess = () => res(r.result);
                });
            }
        };

        // --- CRYPTO UTILS ---
        async function deriveKey(rawBytes) {
            return crypto.subtle.importKey('raw', rawBytes, 'AES-GCM', false, ['encrypt', 'decrypt']);
        }

        async function encrypt(rawKey, text) {
            const key = await deriveKey(rawKey);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, new TextEncoder().encode(text));
            return { iv, ciphertext };
        }

        async function decrypt(rawKey, iv, ciphertext) {
            const key = await deriveKey(rawKey);
            const dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
            return new TextDecoder().decode(dec);
        }

        // --- ПРОВЕРКА ПОДДЕРЖКИ ---
        (async () => {
            const supported = window.PublicKeyCredential && 
                await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
            if (supported) {
                statusEl.innerHTML = '<span class="status-ok">✅ Биометрия поддерживается</span>';
            } else {
                statusEl.innerHTML = '<span class="status-err">❌ Биометрия недоступна</span>';
            }
        })();

        // --- ШАГ 1: РЕГИСТРАЦИЯ И ШИФРОВАНИЕ ---
        document.getElementById('btn-setup').onclick = async () => {
            const master = document.getElementById('inp-master').value;
            const secret = document.getElementById('inp-data').value;
            if (!master || !secret) return alert("Введите данные");

            try {
                // 1. Создаем Passkey
                logger("Создание Passkey...");
                const challenge = crypto.getRandomValues(new Uint8Array(32));
                const userHandle = crypto.getRandomValues(new Uint8Array(16));

                const cred = await navigator.credentials.create({
                    publicKey: {
                        challenge,
                        rp: { name: "Sho App", id: window.location.hostname },
                        user: { id: userHandle, name: "user@sho", displayName: "User" },
                        pubKeyCredParams: [{ alg: -7, type: "public-key" }, { alg: -257, type: "public-key" }],
                        authenticatorSelection: { 
                            authenticatorAttachment: 'platform',
                            userVerification: 'required',
                            residentKey: 'required'
                        },
                        extensions: { prf: { eval: { first: PRF_SALT } } }
                    }
                });

                logger("Passkey создан. Credential ID сохранен.");

                // 2. Сразу после создания делаем GET, чтобы получить PRF ключ
                logger("Запрашиваем PRF-ключ для шифрования...");
                const keyRequest = await navigator.credentials.get({
                    publicKey: {
                        challenge,
                        allowCredentials: [{ id: cred.rawId, type: 'public-key' }],
                        userVerification: 'required',
                        extensions: { prf: { eval: { first: PRF_SALT } } }
                    }
                });

                const extResults = keyRequest.getClientExtensionResults();
                // ИСПРАВЛЕНИЕ: Убрали .eval из пути
                const prfRaw = extResults?.prf?.results?.first;

                if (!prfRaw) {
                    throw new Error("Ваше устройство не вернуло PRF ключ. Попробуйте другой браузер.");
                }

                logger("PRF ключ получен. Шифруем...");
                const encryptedPayload = await encrypt(new Uint8Array(prfRaw), JSON.stringify({ master, secret }));

                await DB.save({
                    credId: cred.rawId,
                    iv: encryptedPayload.iv,
                    data: encryptedPayload.ciphertext
                });

                logger("УСПЕХ! Данные в базе. Обновите страницу для теста.");
                alert("Успешно зарегистрировано!");

            } catch (err) {
                logger("ОШИБКА: " + err.name, err.message);
                console.error(err);
            }
        };

        // --- ШАГ 2: ВХОД ---
        document.getElementById('btn-unlock').onclick = async () => {
            try {
                const record = await DB.get();
                if (!record) return alert("Нет данных в базе");

                logger("Запрос биометрии...");
                const challenge = crypto.getRandomValues(new Uint8Array(32));

                const assertion = await navigator.credentials.get({
                    publicKey: {
                        challenge,
                        allowCredentials: [{ id: record.credId, type: 'public-key' }],
                        userVerification: 'required',
                        extensions: { prf: { eval: { first: PRF_SALT } } }
                    }
                });

                const extResults = assertion.getClientExtensionResults();
                // ИСПРАВЛЕНИЕ: Убрали .eval из пути
                const prfRaw = extResults?.prf?.results?.first;

                if (!prfRaw) throw new Error("Ключ PRF не найден в ответе");

                logger("Ключ получен, расшифровываю...");
                const decrypted = await decrypt(new Uint8Array(prfRaw), record.iv, record.data);
                const result = JSON.parse(decrypted);

                logger("✅ ДОСТУП РАЗРЕШЕН!");
                logger("Мастер-пароль: " + result.master);
                logger("Данные: " + result.secret);

                alert(`Привет! Твой пароль: ${result.master}`);

            } catch (err) {
                logger("ОШИБКА: " + err.message);
                console.error(err);
            }
        };
    </script>
</body>
</html>
