<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn PRF Test</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 500px; margin: auto; line-height: 1.5; }
        .block { border: 1px solid #ccc; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        input { width: 100%; padding: 8px; margin: 5px 0 15px; box-sizing: border-box; }
        button { width: 100%; padding: 10px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
        button:disabled { background: #ccc; }
        #log { background: #f4f4f4; padding: 10px; font-family: monospace; font-size: 12px; white-space: pre-wrap; border-radius: 4px; }
        .status { font-weight: bold; margin-bottom: 10px; }
    </style>
</head>
<body>

    <h2>Biometric Test</h2>
    
    <div id="status" class="status">Проверка поддержки...</div>

    <div class="block">
        <h3>1. Регистрация (Запись)</h3>
        <label>Мастер-пароль:</label>
        <input type="password" id="reg-master" placeholder="Введите пароль">
        <label>Секретные данные:</label>
        <input type="text" id="reg-data" placeholder="Например: Секрет 123">
        <button id="btn-save">Создать ключ и сохранить</button>
    </div>

    <div class="block">
        <h3>2. Авторизация (Чтение)</h3>
        <p>После обновления страницы нажмите кнопку ниже:</p>
        <button id="btn-load">Войти по биометрии</button>
    </div>

    <h4>Лог событий:</h4>
    <div id="log">Ожидание действий...</div>

    <script>
        const LOG = document.getElementById('log');
        const logMsg = (m) => { LOG.innerText += `\n> ${m}`; console.log(m); };

        // Конфигурация
        const DB_NAME = 'PRF_Test_DB';
        const STORE_NAME = 'config';
        const PRF_SALT = new Uint8Array(32).fill(1); // Статичная соль для PRF

        // --- РАБОТА С IDB ---
        async function openDB() {
            return new Promise((res) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
                req.onsuccess = () => res(req.result);
            });
        }

        async function saveToDB(data) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(data, 'biometric_record');
            return new Promise(res => tx.oncomplete = res);
        }

        async function getFromDB() {
            const db = await openDB();
            return new Promise(res => {
                const req = db.transaction(STORE_NAME).objectStore(STORE_NAME).get('biometric_record');
                req.onsuccess = () => res(req.result);
            });
        }

        // --- ПРОВЕРКА ПОДДЕРЖКИ ---
        async function checkSupport() {
            const isWebAuthn = !!window.PublicKeyCredential;
            const isPrf = window.PublicKeyCredential?.isConditionalMediationAvailable; // Грубая проверка
            
            if (!isWebAuthn) {
                document.getElementById('status').innerText = "❌ WebAuthn не поддерживается";
                return false;
            }
            document.getElementById('status').innerText = "✅ WebAuthn доступен. Готов к тесту.";
            return true;
        }

        // --- ШИФРОВАНИЕ ---
        async function encryptData(keyBuffer, plaintext) {
            const key = await crypto.subtle.importKey('raw', keyBuffer, 'AES-GCM', false, ['encrypt']);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const ciphertext = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv }, 
                key, 
                new TextEncoder().encode(plaintext)
            );
            return { iv, ciphertext };
        }

        async function decryptData(keyBuffer, iv, ciphertext) {
            const key = await crypto.subtle.importKey('raw', keyBuffer, 'AES-GCM', false, ['decrypt']);
            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
            return new TextDecoder().decode(decrypted);
        }

        // --- 1. РЕГИСТРАЦИЯ (Исправлено для Safari 18) ---
document.getElementById('btn-save').onclick = async () => {
    const master = document.getElementById('reg-master').value;
    const data = document.getElementById('reg-data').value;
    if (!master || !data) return alert("Заполните поля");

    try {
        logMsg("Запрос биометрии (Safari Passkey)...");
        
        const challenge = crypto.getRandomValues(new Uint8Array(32));
        const userId = crypto.getRandomValues(new Uint8Array(16));

        const credential = await navigator.credentials.create({
            publicKey: {
                challenge,
                rp: { name: "Shifro App", id: window.location.hostname },
                user: { 
                    id: userId, 
                    name: "user@shifro.local", 
                    displayName: "Shifro User" 
                },
                pubKeyCredParams: [{ alg: -7, type: "public-key" }], // ES256
                
                // КРИТИЧНО ДЛЯ SAFARI:
                authenticatorSelection: { 
                    authenticatorAttachment: "platform", // Только FaceID/TouchID
                    residentKey: "required",             // Обязательно Passkey
                    userVerification: "required" 
                },
                
                extensions: {
                    prf: { 
                        eval: { first: PRF_SALT } 
                    }
                }
            }
        });

        const extensionResults = credential.getClientExtensionResults();
        console.log("Debug Extensions:", extensionResults);

        // В Safari 18 PRF может лежать сразу в extensionResults.prf.results
        if (!extensionResults.prf || !extensionResults.prf.results) {
            logMsg("Результат расширений: " + JSON.stringify(extensionResults));
            throw new Error("PRF не поддерживается или не разрешен в настройках Safari.");
        }

        const prfKeyRaw = new Uint8Array(extensionResults.prf.results.eval.first);
        logMsg("Ключ успешно создан!");

        const payload = JSON.stringify({ master, data });
        const encrypted = await encryptData(prfKeyRaw, payload);

        await saveToDB({
            credentialId: credential.rawId,
            iv: encrypted.iv,
            ciphertext: encrypted.ciphertext
        });

        alert("Готово! Пробуйте войти.");

    } catch (e) {
        logMsg("ОШИБКА: " + e.message);
        console.error(e);
    }
};

// --- 2. АВТОРИЗАЦИЯ (Исправлено для Safari 18) ---
document.getElementById('btn-load').onclick = async () => {
    try {
        const record = await getFromDB();
        if (!record) return alert("Запись не найдена.");

        logMsg("Запрос FaceID/TouchID...");

        const challenge = crypto.getRandomValues(new Uint8Array(32));
        const assertion = await navigator.credentials.get({
            publicKey: {
                challenge,
                allowCredentials: [{
                    id: record.credentialId,
                    type: 'public-key'
                }],
                userVerification: "required",
                extensions: {
                    prf: { 
                        eval: { first: PRF_SALT } 
                    }
                }
            }
        });

        const extensionResults = assertion.getClientExtensionResults();
        
        if (!extensionResults.prf || !extensionResults.prf.results) {
            throw new Error("Не удалось извлечь PRF ключ.");
        }

        const prfKeyRaw = new Uint8Array(extensionResults.prf.results.eval.first);
        const decryptedText = await decryptData(prfKeyRaw, record.iv, record.ciphertext);
        const result = JSON.parse(decryptedText);

        logMsg("Взломано! Пароль: " + result.master);
        alert(`Успех!\nМастер-пароль: ${result.master}`);

    } catch (e) {
        logMsg("ОШИБКА: " + e.message);
    }
};

        checkSupport();
    </script>
</body>
</html>
